# トランザクション

- 複数の SQL 文を送る際にひとかたまりとして扱うように指示することができるのがトランザクション。

## トランザクションの例

- A さん -> B さんに 1000 円の送金をする場合のデータ操作を行うとする
- このやり取りで B さんの口座に振り込みをする際にエラーが生じた場合、A さんの口座から 1000 円が消えたままになってしまう。

```
-- Aさんの口座から1000円引く
UPDATE wallet SET balance = balance - 1000 WHERE user_id = 1;

-- Bさんの口座に1000円足す
UPDATE wallet SET balance = balance + 1000 WHERE user_id = 2;
```

- 2 つの UPDATE をトランザクションとして実行することで、「両方とも実行されたか」「両方とも実行されなかったか」を保証できるようになる。

```
BEGIN;

-- Aさんの口座から1000円引く
UPDATE wallet SET balance = balance - 1000 WHERE user_id = 1;

-- Bさんの口座に1000円足す
UPDATE wallet SET balance = balance + 1000 WHERE user_id = 2;

COMMIT;
```

### 自動コミットモードに注意

- DB を扱うクライアントツールの多くは、デフォルト状態で自動コミットモードで動作する。
- [TablePlus](https://docs.tableplus.com/gui-tools/code-review-and-safemode/commit-changes)では GUI からしかコミット・ロールバックが出来なさそう
- MySQL では `SET AUTOCOMMIT=0` の SQL を実行することでデータベースの設定を書き換えることができる

## 同時実行の副作用

トランザクションを利用せずに SQL を複数ユーザーが同時に実行すると、以下のような副作用が発生する。

1. ダーティリード: まだコミットされていない未確定の変更を他の人も読めてしまう副作用。
2. 反復不能読み取り: あるテーブルに対して SELECT を実行した後、別の人が UPDATE でデータを書き換えると、次に SELECT した際に検索結果が異なってしまう副作用。処理中に値が書き換わると処理の不整合が生じてしまう。
3. ファントムリード: あるテーブルに対して SELECT を実行した後、別の人が INSERT でデータを追加すると、次に SELECT した際に検索結果が異なってしまう副作用。1 回目の検索結果の行数に依存する処理を行う場合に問題となることがある。

### 副作用の解決法: トランザクションを分離する

- DBMS はトランザクションを実行する際に、他のトランザクションから影響を受けないようにそれぞれを分離して実行する。
- 分離して実行 = 現在のトランザクションが読み書きしている行に鍵（ロック）をかけ、他のトランザクションからは読み書きできないようにする。
- 自分が読み書きしたい行を他人がロックしている場合、他人のトランザクションが完了するまで待機させられる。
- ロックが多く発生すると、その分待機ユーザーも増えるため、データベースの動作が遅くなることに注意する。

### トランザクションの分離レベル

| 速度 ✖️ 安全 | 分離レベル       | 備考                                                                                                                                                                                                                 | ダーティリード | 反復不能読み取り | ファントムリード |
| ------------ | ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------- | ---------------- |
| 高速・危険   | READ UNCOMMITTED | 他のトランザクションがまだコミットしていないデータ（ダーティデータ）を読み取ることができます。これは最も低い分離レベルで、ダーティリード、反復不能読み取り、ファントムリードの全ての問題が発生する可能性があります。 | 🔥             | 🔥               | 🔥               |
|              | READ COMMITTED   | 他のトランザクションがコミットしたデータのみを読み取ることができます。                                                                                                                                               |                | 🔥               | 🔥               |
|              | REPEATABLE READ  | トランザクションが開始された時点のデータを読み取ることができます。                                                                                                                                                   |                |                  | 🔥               |
| 低速・安全   | SERIALIZABLE     | 最も高い分離レベルで、トランザクションは完全に分離されます。ダーティリード、反復不能読み取り、ファントムリードの全ての問題を防ぎますが、パフォーマンスは最も低下する可能性があります。                               |                |                  |                  |

## ロックの活用

- トランザクションを実行すると自動的に必要な行に対してロックをかけることができる。
- …が、SQL を使って対象を明示的にロックすることも可能。
- ロックした行は他ユーザーは使えなくなるので「必要最小限」の範囲にとどめるようにしよう。

| 種類               | 備考                               |
| ------------------ | ---------------------------------- |
| 行ロック           | 特定の行だけをロックする           |
| 表ロック           | 特定のテーブル全体をロックする     |
| データベースロック | 特定のデータベース全体をロックする |

| 制限の強さ              | 備考                             | 用途               |
| ----------------------- | -------------------------------- | ------------------ |
| 排他ロック（EXCLUSIVE） | 他からのロックを一切許可しない。 | データ更新時       |
| 共有ロック（SHARE）     | 他からの共有ロックを許可する     | データの読み取り時 |

### 明示的な行ロック

```
BEGIN;

-- 同じ行がロックされている場合、待機状態になる。
SELECT カラム FROM テーブル名 FOR UPDATE;

-- 他者がロックをかけている場合はすぐにロック失敗のエラーを返してくれるので待機時間が発生しない。
SELECT カラム FROM テーブル名 FOR UPDATE NO WAIT;

COMMIT;
```

### 明示的な表ロック

```
BEGIN;

LOCK TABLE テーブル名 IN モード名 MODE;

-- こっちもNO WAITオプションがある
LOCK TABLE テーブル名 IN モード名 MODE NO WAIT;
```

### デッドロック

- データベース上で同時に多くのトランザクションが実行された際に、お互いのトランザクションがロックしたい行の解除を待ち続けてしまう状態。
- トランザクションの時間を短くする、各処理同じ順番で行をロックするなどで回避する。
